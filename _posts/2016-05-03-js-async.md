---
title: 浅析js异步
categories: [JavaScript]
date:2016-05-03
url:2016-05-03-js-async
---

# js异步

## 九句话轻松理解线程与异步以及回调函数。

1. 在js中没有多线程，也就是说，在同一个时间只执行一个任务
2. 但是如果真是这样，那么像一些事件(如用户点击)，如果永远不点击，那么后面的代码就永远都要一直等待，这个等待是无意义的，并且cpu也是空闲的
3. 所以把任务分成两种:同步任务和异步任务
4. 所谓『同步任务』，就是一般任务，在js中一个一个的按续执行
5. 所有同步任务都在主线程上执行，形成『执行栈』
6. 『异步任务』就是如(dom event, timer)，他们并不先执行，而且先将它们放到『任务队列』中(task queue)，先进先出的执行。
7. 『异步任务』中必须指定『回调函数』，『回调函数』就是被主线程挂起来的代码，当主线程要执行『异步任务』时，实际上就是执行回调函数
8. 队列任务总是等执行栈中同步任务全部完成之后才执行
9. 当执行栈的任务执行完后，开始读取队列任务中可以执行的任务(回调函数)，这时就将回调函数加入到执行栈中执行，然后如此循环

分解来讲就是

## 问题

在JavaScript中大部分代码都是同步一个一个执行的，如果此时你写了一个`click`事件，那用户没有触发这个click，那按照同步的思想，click事件后面的代码都不会执行，直到你触发该事件为止，这就抛出了一个问题，我们如何来处理这些事件？要知道JavaScript是没有多线程的。（关于多线程可以看我的这篇文章）

## 方法

这时就是异步出场的时候了。对于异步任务，JavaScript并不直接执行，而是将它推入一个队列（关于队列可以看[栈与队列](http://www.sunopar.com/2016/05/03/js-async.html)），队列中存储的函数就是一个个的回调函数。等当前[执行环境](http://www.sunopar.com/2016/04/22/excution-context.html)执行完毕后，再执行队列中的回调函数。

## 例子

例子就比如说`setTimeout()`函数。

```
function a(num) {
	for (var i = 0; i < num; i++) {
		(function(i) {
			setTimeout(function() {
				console.log("b:" + i);
			}, 10);
		})(i);
		console.log("a:" + i);
	}
}
a(5);
```
最后的输出为：

>eventUtil.js:42 a:0
eventUtil.js:42 a:1
eventUtil.js:42 a:2
eventUtil.js:42 a:3
eventUtil.js:42 a:4
eventUtil.js:38 b:0
eventUtil.js:38 b:1
eventUtil.js:38 b:2
eventUtil.js:38 b:3
eventUtil.js:38 b:4

### 例子解释

可以看出先执行的是第42行的代码，后执行的是第38行代码，这很明显是因为第38行的代码是异步代码；而从`b`的输出是从0-4可以看出，这个异步代码被存放在是队列，因为这是先进先出加载的。